// Each #kernel tells which function to compile; you can have many kernel

#pragma kernel UpdateParticules



// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
struct Particule{
    float2 position;
    float2 velocity;
    float radius;
};

int particuleCount;
float deltaTime;

float2 border;

RWStructuredBuffer<Particule> particules;


float norm_2(float2 vect){
    return pow(vect.x,2)+pow(vect.y,2);
}


bool isInRadius(float2 pos1, float2 pos2, float radius){
    return norm_2(pos1-pos2) < radius;
}

bool isInBorder(float2 pos){
    return pos.x < border.x && pos.y < border.y;
}


[numthreads(128,1,1)]
void UpdateParticules (uint3 id : SV_DispatchThreadID)
{
    float2 position = particules[id.x].position;
    float2 velocity = particules[id.x].velocity;
    [loop]
    for (uint i =0;i<(uint)(particuleCount);i++){
        if (i==id.x) continue;
        if (isInRadius(position,particules[i].position,particules[i].radius)){
            velocity =-velocity/2;
            particules[i].velocity = -particules[i].velocity/2;
        }
        if (!isInBorder(position)){
            velocity =-velocity/2;
        }
    }
    GroupMemoryBarrierWithGroupSync();

    position += velocity* deltaTime;
    particules[id.x].position = position;
    particules[id.x].velocity = velocity;
}





